#include "stm32f4xx.h"                  // Device header

void My_USART1_Init(void)  
{  
	RCC->APB2ENR |= 1 << 4;//RCC_APB2Periph_USART1 = (uint32_t)0x00000010
     
	RCC->AHB1ENR |= 2;//RCC_AHB1Periph_GPIOB=0x00000002
	
	GPIOB->MODER &= ~( 3 << (6 * 2)|3 << (7 * 2));
	GPIOB->MODER |= (2 << (6 * 2)|2 << (7 * 2));//AF(TXRX)
 
	GPIOB->OSPEEDR &= ~(3 << (6 * 2));
    GPIOB->OSPEEDR |= (2 << (6 * 2));//PB6:FAST SPEED

	GPIOB->PUPDR |= (1 << (6 * 2));//PB6:pull-up 
	
	//GPIOB->AFR[0] &= ~( 0xFF << 24);//清除
	GPIOB->AFR[0] |= 7 << 24;//设置AF7
	GPIOB->AFR[0] |= 7 << 28;
	
	USART1->CR1 &= ~(1 << 15);//过采样16
	USART1->CR1 &= ~(1 << 12);//数据字长，选择8字长
	USART1->CR1 |= (1 << 3) | (1 << 2);//开启收发
	USART1->CR2 &=	~(3 << 12);//停止位1位
	
	 
	float USARTDIV; 
	unsigned int DIVM;
	unsigned int DIVF;
	USARTDIV = 84000000/16/28800;//波特率28800,这里的波特率有些不常见，如果有疑问可以参考此文件末尾的注释
	
	DIVM = (uint32_t) USARTDIV;
	DIVF = (USARTDIV - DIVM)*16;
	
	USART1->BRR = DIVM<<4|DIVF;//BRR寄存器 
	
	NVIC->ISER[1]|= 1 << 5;//激活中断
	USART1->CR1  |= 1 << 5;//打开RXNEIE
	
	SCB->AIRCR = 0x05FA0500;//优先级分组
	NVIC->IP[37] = 0xF0;//优先级
	
	USART1->CR1 |= 1<<13;//USART enable
	
}  

void USART_SendByte(int8_t Byte){
	
	while (!(USART1->SR &(1 << 7))){
		//wait
	}
	USART1->DR = Byte & 0x01ff;
}



void USART1_IRQHandler(void)  
{ 
		uint16_t data;
	if (USART1->SR & (1 << 5) ){//RXNEIE
		data = (USART1->DR & (uint16_t)0x01FF);//Receive
		USART1->SR &= ~(1 << 5);//清零
		USART_SendByte(data);//回传
	}
} 








/*
		如果日后我自己忘记了波特率的问题，希望不要对这个波特率表示疑惑，这里做一点说明：
	这个波特率适配的是我2023年在淘宝买的“HM-10”蓝牙模块，可惜的是，这个蓝牙模块并不是HM-10，后来我找到了MLT-BT05蓝牙模块的说明书，
	我原本以为这个模块是BT05模块，于是使用BT05的AT指令集，遗憾的是，虽然BT05的AT指令集能成功使用，但是蓝牙依旧无法正常工作，排除代码和我配置流程的问题之后，
	我怀疑是波特率的问题，于是我自拟了一个数据，从最经典的波特率9600（按照AT指令集，我设置的是115200的波特率）开始测试，发现9600的波特率会导致数据	缺位，
	这就说明了波特率应当是大于9600的，然后测试19200，数据还是不正确，比较常见的38400、57600、115200都会导致数据传输错误，而且这个错误是有规律的，
	只有其中的一部分位会错误，于是，错误在波特率的这一观点就得到有力的支撑（错误有规律而不是无规律，首先排除硬件工作错误）， 我开始考虑一个问题：
	波特率理应是9600的倍频（当然早期还有2400和4800，也许还有7200）而我们试了9600 *2 、9600 *4、 9600*6 、9600*12，于是我从9600*3开始测试，这下数据就正确了。
	这里给出我测试时的一点记录作为参考，日后有类似问题可以试一试这个方面：
	-------------------------------------------------------------
	|real data:0100 1000 0100 0101 0100 1100 0100 1100 0100 1111|
	-------------------------------------------------------------
	|9600	  :1111 0100 0001 1100 1111 1100 1111 1100			|
	-------------------------------------------------------------
	|19200	  :0110 0000 1000 1100 1001 1100 0110 1100 1111 0010|
	-------------------------------------------------------------
	|28800 	  :0100 1000 0100 0101 0100 1100 0100 1100 0100 1111|
	-------------------------------------------------------------
	*/
	

